package yh.algorithm.sort.bubble;

import yh.algorithm.sort.util.SortTestHelper;

/**
 * 冒泡排序
 */

/**
 * 举例说明：要排序数组：int[] arr={6,3,8,2,9,1};
 *
 * 第一趟排序：
 *
 * 　　　　第一次排序：6和3比较，6大于3，交换位置：  3  6  8  2  9  1
 *
 * 　　　　第二次排序：6和8比较，6小于8，不交换位置：3  6  8  2  9  1
 *
 * 　　　　第三次排序：8和2比较，8大于2，交换位置：  3  6  2  8  9  1
 *
 * 　　　　第四次排序：8和9比较，8小于9，不交换位置：3  6  2  8  9  1
 *
 * 　　　　第五次排序：9和1比较：9大于1，交换位置：  3  6  2  8  1  9
 *
 * 　　　　第一趟总共进行了5次比较， 排序结果：      3  6  2  8  1  9
 *
 * ---------------------------------------------------------------------
 *
 * 第二趟排序：
 *
 * 　　　　第一次排序：3和6比较，3小于6，不交换位置：3  6  2  8  1  9
 *
 * 　　　　第二次排序：6和2比较，6大于2，交换位置：  3  2  6  8  1  9
 *
 * 　　　　第三次排序：6和8比较，6大于8，不交换位置：3  2  6  8  1  9
 *
 * 　　　　第四次排序：8和1比较，8大于1，交换位置：  3  2  6  1  8  9
 *
 * 　　　　第二趟总共进行了4次比较， 排序结果：      3  2  6  1  8  9
 *
 * ---------------------------------------------------------------------
 *
 * 第三趟排序：
 *
 * 　　　　第一次排序：3和2比较，3大于2，交换位置：  2  3  6  1  8  9
 *
 * 　　　　第二次排序：3和6比较，3小于6，不交换位置：2  3  6  1  8  9
 *
 * 　　　　第三次排序：6和1比较，6大于1，交换位置：  2  3  1  6  8  9
 *
 * 　　　　第二趟总共进行了3次比较， 排序结果：         2  3  1  6  8  9
 *
 * ---------------------------------------------------------------------
 *
 * 第四趟排序：
 *
 * 　　　　第一次排序：2和3比较，2小于3，不交换位置：2  3  1  6  8  9
 *
 * 　　　　第二次排序：3和1比较，3大于1，交换位置：  2  1  3  6  8  9
 *
 * 　　　　第二趟总共进行了2次比较， 排序结果：        2  1  3  6  8  9
 *
 * ---------------------------------------------------------------------
 *
 * 第五趟排序：
 *
 * 　　　　第一次排序：2和1比较，2大于1，交换位置：  1  2  3  6  8  9
 *
 * 　　　　第二趟总共进行了1次比较， 排序结果：  1  2  3  6  8  9
 *
 * ---------------------------------------------------------------------
 *
 * 最终结果：1  2  3  6  8  9
 */
public class BubbleSort
{
    // 我们的算法类不允许产生任何实例
    private BubbleSort()
    {
    }

    public static <T extends Comparable<T>> void sort(T[] arr)
    {

        int n = arr.length;
        boolean swapped;
        //int newn; // 理论上,可以使用newn进行优化,但实际优化效果较差
        do
        {
            swapped = false;
            //newn = 0;
            for (int i = 1; i < n; i++)
            {
                if (arr[i - 1].compareTo(arr[i]) > 0)//前面的数大于后面的就交换位置
                {
                    swap(arr, i - 1, i);
                    swapped = true;

                    // 可以记录最后一次的交换位置,在此之后的元素在下一轮扫描中均不考虑
                    // 实际优化效果较差,因为引入了newn这个新的变量
                    //newn = n;
                }
            }

            //n = newn;

            // 优化, 每一趟Bubble Sort都将最大的元素放在了最后的位置
            // 所以下一次排序, 最后的元素可以不再考虑
            // 理论上, newn的优化是这个优化的复杂版本,应该更有效
            // 实测, 使用这种简单优化, 时间性能更好
            n--;
        } while (swapped);
    }

    private static void swap(Object[] arr, int i, int j)
    {
        Object t = arr[i];
        arr[i] = arr[j];
        arr[j] = t;
    }

    public static void main(String[] args)
    {
        int N = 20;
        Integer[] arr = SortTestHelper.generateRandomArray(N, 0, 20);
        sort(arr);
        SortTestHelper.printArray(arr);
    }
}
